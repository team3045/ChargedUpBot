// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.



package frc.robot.subsystems;

import org.photonvision.PhotonCamera;
import org.photonvision.targeting.PhotonTrackedTarget;
import org.photonvision.PhotonUtils;
import edu.wpi.first.wpilibj2.command.SubsystemBase;



import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.math.util.Units;

import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.motorcontrol.PWMVictorSPX;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS



/**
 *
 */
public class PhotoVision extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    /**
    *
    */

    // Variables

    final double CAMERA_PITCH_RADIANS = Units.degreesToRadians(0);
    final double GOAL_RANGE_METERS = Units.feetToMeters(3);
    public final PhotonCamera camera = new PhotonCamera("BreadCam");
    private final double cameraHeightMeters = 0.51;
    private final double targetHeightMeters = 2.5;
    private final double cameraPitchRadians = Units.degreesToRadians(31.0);
    private double yaw;
    private double pitch;
    private double distance;
    private boolean hasTargets;
    public final VisionSupplier visionSupplier = new VisionSupplier();
    PWMVictorSPX leftMotor = new PWMVictorSPX(0);
    PWMVictorSPX rightMotor = new PWMVictorSPX(1);
    DifferentialDrive drive = new DifferentialDrive(leftMotor, rightMotor);
    // PID constants should be tuned per robot
    //THIS NEEDS TO BE TUNED!!!
    //cuz I haven't done that yet
    final double LINEAR_P = 0.1;
    final double LINEAR_D = 0.0;
    PIDController forwardController = new PIDController(LINEAR_P, 0, LINEAR_D);

    final double ANGULAR_P = 0.1;
    final double ANGULAR_D = 0.0;
    PIDController turnController = new PIDController(ANGULAR_P, 0, ANGULAR_D);
    

    public PhotoVision() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    }

    public void execute() {
        double rotationSpeed;
        double forwardSpeed;
        //xboxcontroller, prob change port number.
        

        rotationSpeed = 15;
        forwardSpeed = 15;

       
            //assist mode, aim at target.
            var result = camera.getLatestResult();

            if (result.hasTargets()) {

                double range =
                        PhotonUtils.calculateDistanceToTargetMeters(
                                cameraHeightMeters,
                                targetHeightMeters,
                                CAMERA_PITCH_RADIANS,
                                Units.degreesToRadians(result.getBestTarget().getPitch()));

                forwardSpeed = -forwardController.calculate(range, GOAL_RANGE_METERS);

                rotationSpeed = -turnController.calculate(result.getBestTarget().getYaw(), 0);

                hasTargets = true;
                PhotonTrackedTarget target = result.getBestTarget();
                yaw = target.getYaw();
                pitch = target.getPitch();

                distance = PhotonUtils.calculateDistanceToTargetMeters(
                        cameraHeightMeters,
                        targetHeightMeters,
                        cameraPitchRadians,
                        Units.degreesToRadians(pitch));
            } else {
                hasTargets = false;
                rotationSpeed = 0;
            }
        
        drive.arcadeDrive(forwardSpeed, rotationSpeed);
    }

    @Override
    public void periodic() { 
        // This method will be called once per scheduler run
        
    }


    
    
    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public class VisionSupplier {

        // Method to get the yaw
        public double getYaw() {
            return -yaw;
        }
        
        // Method to get the pitch
        public double getPitch() {
            return pitch;
        }

        // Method to get the distance 
        public double getDistance() {
            return distance;
        }

        // Method to check whether vision has targets
        public boolean hasTarget() {
            return hasTargets;
        }

    }
}

