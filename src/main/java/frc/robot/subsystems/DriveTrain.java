// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import frc.robot.Constants;
import frc.robot.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import com.ctre.phoenix.sensors.Pigeon2;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
//import edu.wpi.first.wpilibj.motorcontrol.MotorController;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;
import com.ctre.phoenix.motorcontrol.TalonFXControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.GroupMotorControllers;
import com.ctre.phoenix.motorcontrol.InvertType;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;
import com.ctre.phoenix.motorcontrol.ControlMode;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class DriveTrain extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
public WPI_TalonFX leftMotor1;
public WPI_TalonFX leftMotor2;
public WPI_TalonFX leftMotor3;
public WPI_TalonFX rightMotor1;
public WPI_TalonFX rightMotor2;
public WPI_TalonFX rightMotor3;
private DifferentialDrive differentialDrive;
public Pigeon2 pigeon;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
  public final DifferentialDrive m_drive=null;

  private DriveMode driveMode;
  
  public enum DriveMode {
      TANK, CHEEZY, ARCADE;
    }
  
    /**
    *
    */
    public DriveTrain() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        leftMotor1 = new WPI_TalonFX(3);
        addChild("LeftMotor1",leftMotor1);
        leftMotor1.setInverted(false);

        leftMotor2.follow(leftMotor1);
        leftMotor2.setInverted(InvertType.FollowMaster);
        leftMotor3.follow(leftMotor1);
        leftMotor3.setInverted(InvertType.FollowMaster);
        rightMotor2.follow(rightMotor1);
        rightMotor2.setInverted(InvertType.FollowMaster);
        rightMotor3.follow(rightMotor1);
        rightMotor3.setInverted(InvertType.FollowMaster);

        pigeon = new Pigeon2(Constants.pigeonCanId);
        
        m_drive = new DifferentialDrive(leftMotor1, rightMotor2);
        //m_drive.setDeadband(0.05);

        leftMotor1.configSelectedFeedbackSensor(FeedbackDevice.IntegratedSensor, 0, 0);
        rightMotor1.configSelectedFeedbackSensor(FeedbackDevice.IntegratedSensor, 0, 0);
        leftMotor1.setNeutralMode(NeutralMode.Brake);
        rightMotor1.setNeutralMode(NeutralMode.Brake);

        differentialDrive = new DifferentialDrive(leftMotor1, rightMotor1);
        addChild("Differential Drive", differentialDrive);
        differentialDrive.setSafetyEnabled(true);
        differentialDrive.setExpiration(0.1);
        differentialDrive.setMaxOutput(1.0);

        driveMode = driveMode.TANK;

        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    public void tankDrive(double leftpower, double rightpower) {
        m_drive.tankDrive(leftpower, rightpower);
        m_drive.feed();
      }
    
      public void cheezyDrive(double straight, double turn) {
        m_drive.curvatureDrive(straight, -turn, false);
      }
    
      public void arcadeDrive(double straight, double turn) {
        m_drive.arcadeDrive(straight, -turn);
      }
    
      public void stopDrive() {
        leftMotor1.set(ControlMode.PercentOutput, 0);
        rightMotor1.set(ControlMode.PercentOutput, 0);
      }
        
      public void resetEncoders() {
        leftMotor1.setSelectedSensorPosition(0);
        rightMotor1.setSelectedSensorPosition(0);
      }
    
      public double getLeftEncoder() {
          return (leftMotor1.getSelectedSensorPosition());
      }
    
      public double getRightEncoder() {
        return (rightMotor1.getSelectedSensorPosition());
    }
    
      public double getAverageEncoder(){
        return ((getLeftEncoder()+getRightEncoder())/2);
      }
    
      public void setMaxOutput(double maxOutput) {
          m_drive.setMaxOutput(maxOutput);
      }
      
      public double getRawEncoder() {
        return leftMotor1.getSelectedSensorPosition(); //temp method
      }
    
      public DriveMode getDriveMode(){
        return driveMode;
      }
    
      public void setDriveMode(DriveMode driveMode) {
          this.driveMode = driveMode;

          // Put methods for controlling this subsystem
          // here. Call these from Commands.
      }

      public void stop() {
        leftMotor1.set(0.0);
        rightMotor1.set(0.0);
      }
}
